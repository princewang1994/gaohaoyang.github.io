## 树状数组总结

[TOC]

### 前言：前缀和

我们以一个看似简单“前缀和”问题引入：给定数组`A=[2, 3, 4, 3, 2, 1, 8, 9, 4, 0, 4, 3, 2, 14]`，对于数组的每一个数`A[i]`，我们需要求`A[0] + A[1] +... A[i]`的结果。

问题看似简单，我们可以在O(n)里面解决，只需要设置一个初值为0的变量s，并把数组从头到尾遍历一遍，不断往s里面加入数字，就可以求出每一个位置的前缀和，结果可以用一个一个数组`S`来保存，因此有`S[i] = A[0] + A[1] +... A[i]`。

我们分析一下算法的复杂度：很显然计算每个位置的前缀累加和所需的时间复杂度是O(n)，在数组不更新的情况下，每次查询我们都可以用O(1)的时间内返回任意位置的前缀和。

那么如果数组可以更新呢，我们当然也可以用这种方法算出来，比如我们给`A[3]`加上5，很显然对于数组`S[3]`及其以后的点，我们都需要更新，才能保证查询的时候能返回正确的值，最坏的情况下，我们需要更新整个`S`的值，因此更新的复杂度是O(n)。

### 树状数组

树状数组，又叫二叉索引树（Binary Indexed Tree, B.I.T）能够在O(log(n))的时间复杂度内完成上面的操作，即**更新任意位置的值**和**查询任意位置的前缀和**两种操作，那么树状数组是如何做到的呢？

> 许多博客喜欢用树状的图来解释树状数组，然而这种方法不是很好理解，原因是树状数组的父节点和子节点的关系不是非常直观，因此本篇文章主要使用二进制的方法来解释树状数组。

#### 求前缀和操作

我们首先要有一种二进制（或者说二分）的思维，我们举一个简单的例子，假设我们的数组下标以1开始，要求`S[13]`，我们可以先把13转换为二进制，也就是`01101`，我们知道`13 = 8 + 4 + 1, 01101 = 01000 + 00100 + 00001`，因此我们可以先求前1~8个数的和，然后再求9~12的和，然后求13~13的和，最后全加起来就得到了`S[13]`即：

- `S[1101] = Sum(A[0001], A[1000]) + Sum(A[1001], A[1100]) + Sum(A[1101], A[1101])`

翻译成10进制就是这样：

- `S[13] = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13)`

如果这些数开始就存下来用`C[8]`存储`RANGE(1, 8)`，`C[12]`存`RANGE(9, 12)`，`C[13]`存`RANGE(13, 13)`，我们就只需要加3次就能求出`S[13]`了！我们列一个表来说明这个过程：

- `S[1101] = C[1101] + C[1100] + C[1000]`
- `C[1101] = 1101`: 1个数A[13]
- `C[1100] = 1100 -> 1011 -> 1010 -> 1001`：4个数A[12] + A[11] + A[10] + A[9]
- `C[1000] = 1000 -> 0111 -> 0110 -> 0101 -> 0100 -> 0011 -> 0010 -> 0001`：8个数，A[8]+…A[1]

现在看到规律了吗，C的每个位置C[i]都保存着`RANGE(i - lowbit(i), i]`的和，lowbit是什么呢，就是二进制把所有多余的1去掉，只留下最后一个1的数字，比如`lowbit(1101) = 0001，lowbit(1100) = 0100`，所以`(i - lowbit(i), i]`这个区间长度刚好是$2^k$,$k$即lowbit(i)对应的位置。加完`C[i]`继续加`C[i - lowbit(i)`，直到为0，就得到了前缀和的结果，我们就可以写出求前缀和操作的代码：

```c++
//A[1] + A[2] +... A[k]的前缀和
int sum(int k){
    int s = 0;
    while(k){
        s += A[k];
        k -= k & -k;
    }
    return s;
}
```

#### 更新操作

通过求和的操作我们知道了，C[i]保存着`RANGE(i - lowbit(i), i]`的和，那么C的每个位置都覆盖A数组的某一个区间